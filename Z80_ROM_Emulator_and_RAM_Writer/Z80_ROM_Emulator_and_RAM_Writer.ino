/*
 * Z80_ROM_Emulator_and_RAM_Writer.ino
 * 
 * Z80 pins --- MEGA2560 pins
 *       A0 --- PA0/AD0  (22)
 *       A1 --- PA1/AD1  (23)
 *       A2 --- PA2/AD2  (24)
 *       A3 --- PA3/AD3  (25)
 *       A4 --- PA4/AD4  (26)
 *       A5 --- PA5/AD5  (27)
 *       A6 --- PA6/AD6  (28)
 *       A7 --- PA7/AD7  (29)
 *       A8 --- PC0/A8   (37)
 *       A9 --- PC1/A9   (36)
 *      A10 --- PC2/A10  (35)
 *      A11 --- PC3/A11  (34)
 *      A12 --- PC4/A12  (33)
 *      A13 --- PC5/A13  (32)
 *      A14 --- PC6/A14  (31)
 *      A15 --- PC7/A15  (30)
 * 
 *       D0 --- PL0      (49)
 *       D1 --- PL1      (48)
 *       D2 --- PL2      (47)
 *       D3 --- PL3      (46)
 *       D4 --- PL4      (45)
 *       D5 --- PL5      (44)
 *       D6 --- PL6      (43)
 *       D7 --- PL7      (42)
 * 
 *      !WR --- PG0/!WR  (41)
 *      !RD --- PG1/!RD  (40)
 *    !MREQ --- PG2/ALE  (39)
 *   !IOREQ --- PD7/T0   (38)
 *  !ROM_WR --- PB7      (13)
 *   !RESET --- PB6      (12)
 *  !BUSACK --- PB5      (11)
 *  !BUSREQ --- PB4      (10)
 *
 *
 * Created 31 May 2020 (amid CoViD-19 outbreaks)
 * by ZulNs
 * @Gorontalo, Indonesia
 * 
 * This code is in the public domain.
 * 
 * https://github.com/ZulNs/Arduino_ROM_Emulator
 */

#ifndef USE_ROM_WR
#define USE_ROM_WR          1
#endif

#include <SPI.h>
#include <SD.h>

#define set_WR(sv)          bitWrite(PORTG,PG0,sv)
#define drive_WR()          set_WR(1);bitWrite(DDRG,PG0,1)
#define release_WR()        bitWrite(DDRG,PG0,0)

#define set_RD(sv)          bitWrite(PORTG,PG1,sv)
#define drive_RD()          set_RD(1);bitWrite(DDRG,PG1,1)
#define release_RD()        bitWrite(DDRG,PG1,0)

#define set_MREQ(sv)        bitWrite(PORTG,PG2,sv)
#define drive_MREQ()        set_MREQ(1);bitWrite(DDRG,PG2,1)
#define release_MREQ()      bitWrite(DDRG,PG2,0)

#define set_IORQ(sv)        bitWrite(PORTD,PD7,sv)
#define drive_IORQ()        set_IORQ(1);bitWrite(DDRD,PD7,1)
#define release_IORQ()      bitWrite(DDRD,PD7,0)

#define set_ROM_WR(sv)      bitWrite(PORTB,PB7,sv)
#define drive_ROM_WR()      set_ROM_WR(1);bitWrite(DDRB,PB7,1)
#define release_ROM_WR()    bitWrite(DDRB,PB7,0);set_ROM_WR(0)

#define drive_RST()         bitWrite(PORTB,PB6,0);bitWrite(DDRB,PB6,1)
#define release_RST()       bitWrite(DDRB,PB6,0)

#define drive_BUSREQ()      bitWrite(PORTB,PB4,0);bitWrite(DDRB,PB4,1)
#define release_BUSREQ()    bitWrite(DDRB,PB4,0)

#define is_BUSACK()         bit_is_clear(PINB,PB5)

#define put_ADDR_BUS(addr)  PORTA=lowByte(addr);PORTC=highByte(addr)
#define drive_ADDR_BUS()    DDRA=DDRC=0xFF
#define release_ADDR_BUS()  DDRA=PORTA=DDRC=PORTC=0x00

#define get_DATA_BUS()      PINL
#define drive_DATA_BUS()    DDRL=0xFF
#define put_DATA_BUS(dt)    PORTL=(dt)
#define release_DATA_BUS()  DDRL=PORTL=0x00

#define NOP                 __asm__ __volatile__ ("nop\n\t")

#define ROM_ADDRESS         0x0000
#define ROM_SIZE            0x0800   // 2kB

#define SDCARD_CS_PIN       53

enum HEX_FILE_STATUS {
  OK,
  END_OF_FILE,
  INVALID_START_CODE,
  INVALID_DATA_COUNT,
  EXCEED_16_BYTES_DATA,
  INVALID_ADDRESS,
  INVALID_RECORD_TYPE,
  UNSUPPORTED_RECORD_TYPE,
  INVALID_DATA,
  INVALID_CHECKSUM,
  INVALID_END_OF_FILE
};

enum SERIAL_STATE {
  BEGIN,
  COMMAND,
  SPACE,
  PARAM,
  AVOID
};

const uint8_t PROGMEM ROM_DATA[] = {
  // Address 0x0000:
  0x06, 0x00, 0x10, 0xFE, 0x3E, 0x90, 0xD3, 0x03, 0x3E, 0xC0, 0xD3, 0x02, 0x31, 0xAF, 0x1F, 0x3A,
  0xE5, 0x1F, 0xFE, 0xA5, 0xC4, 0xC1, 0x03, 0x21, 0x00, 0x10, 0xCD, 0xF6, 0x05, 0x28, 0x02, 0x26,
  0x18, 0x22, 0xDC, 0x1F, 0x26, 0x00, 0x18, 0x0A, 0xE3, 0x2B, 0xE3, 0x22, 0xE8, 0x1F, 0x18, 0x0E,
  0x18, 0x34, 0x22, 0xD2, 0x1F, 0x18, 0x1D, 0x71, 0xE5, 0x2A, 0xEE, 0x1F, 0xE3, 0xC9, 0x32, 0xE7,
  0x1F, 0x2A, 0xE0, 0x1F, 0x3A, 0xE2, 0x1F, 0x77, 0x3E, 0x80, 0xD3, 0x02, 0x3A, 0xE7, 0x1F, 0x2A,
  0xE8, 0x1F, 0x00, 0xC9, 0x21, 0x9F, 0x1F, 0x22, 0xD0, 0x1F, 0xAF, 0x32, 0xE6, 0x1F, 0xDD, 0x21,
  0x9F, 0x07, 0xC3, 0xD0, 0x00, 0xFF, 0x32, 0xE7, 0x1F, 0x3E, 0x90, 0xD3, 0x03, 0x3E, 0xC0, 0xD3,
  0x02, 0x3A, 0xE7, 0x1F, 0x22, 0xE8, 0x1F, 0xE1, 0x22, 0xDE, 0x1F, 0x22, 0xDC, 0x1F, 0x2A, 0xE8,
  0x1F, 0xED, 0x73, 0xD0, 0x1F, 0x31, 0xD0, 0x1F, 0xFD, 0xE5, 0xDD, 0xE5, 0xD9, 0xE5, 0xD5, 0xC5,
  0xD9, 0x08, 0xF5, 0x08, 0xE5, 0xD5, 0xC5, 0xF5, 0xED, 0x57, 0x32, 0xD3, 0x1F, 0x3E, 0x00, 0xE2,
  0xA4, 0x00, 0x3E, 0x01, 0x32, 0xD2, 0x1F, 0x31, 0xAF, 0x1F, 0x2A, 0xD0, 0x1F, 0xDD, 0x21, 0xB5,
  0x07, 0x2B, 0xCD, 0xF6, 0x05, 0x20, 0x19, 0x2B, 0xCD, 0xF6, 0x05, 0x20, 0x13, 0xDD, 0x21, 0xAF,
  0x07, 0x00, 0x00, 0x11, 0x62, 0xE0, 0x19, 0x38, 0x07, 0xDD, 0x21, 0xB6, 0x1F, 0x37, 0x18, 0x04,
  0xAF, 0x32, 0xE4, 0x1F, 0x3A, 0xE2, 0x1F, 0x2A, 0xE0, 0x1F, 0x77, 0xDC, 0x0B, 0x04, 0x31, 0xAF,
  0x1F, 0xCD, 0xFE, 0x05, 0xCD, 0xCB, 0x06, 0x18, 0xF5, 0xFE, 0x10, 0x38, 0x24, 0x21, 0xE6, 0x1F,
  0xCB, 0xC6, 0xD6, 0x10, 0xFE, 0x08, 0x21, 0x37, 0x07, 0xDA, 0xB0, 0x03, 0xDD, 0x21, 0xB6, 0x1F,
  // Address 0x0100:
  0xD6, 0x08, 0x21, 0xE4, 0x1F, 0x77, 0x21, 0xE3, 0x1F, 0x36, 0x00, 0x21, 0x41, 0x07, 0xC3, 0xB0,
  0x03, 0x4F, 0x21, 0x4B, 0x07, 0x3A, 0xE4, 0x1F, 0xC3, 0xB0, 0x03, 0x21, 0x57, 0x07, 0x18, 0xF5,
  0x21, 0x63, 0x07, 0x18, 0xF0, 0x21, 0x6F, 0x07, 0x18, 0xEB, 0xCD, 0xE5, 0x03, 0xC2, 0xBB, 0x03,
  0x3E, 0x80, 0xC3, 0xA3, 0x02, 0xCD, 0xE5, 0x03, 0x20, 0x04, 0xCD, 0x0B, 0x04, 0xC9, 0xFE, 0x08,
  0xDA, 0xBB, 0x03, 0xCD, 0x77, 0x04, 0xC9, 0xCD, 0xE5, 0x03, 0xC2, 0xBB, 0x03, 0x2A, 0xDE, 0x1F,
  0xCD, 0xF6, 0x05, 0xC2, 0xBB, 0x03, 0x22, 0xE0, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0xCD, 0xE5, 0x03,
  0xC2, 0xBB, 0x03, 0x2A, 0xDE, 0x1F, 0x00, 0x22, 0xAF, 0x1F, 0x23, 0x22, 0xB3, 0x1F, 0xCD, 0xF6,
  0x05, 0xC2, 0xBB, 0x03, 0x11, 0xFE, 0x1D, 0x7C, 0xFE, 0x1E, 0x38, 0x07, 0xFE, 0x20, 0xDA, 0xBB,
  0x03, 0x16, 0x27, 0xED, 0x53, 0xB1, 0x1F, 0xCD, 0xE4, 0x02, 0xAF, 0x12, 0x2A, 0xB3, 0x1F, 0x22,
  0xDE, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0xCD, 0xE5, 0x03, 0xC2, 0xBB, 0x03, 0x2A, 0xDE, 0x1F, 0x00,
  0x22, 0xB3, 0x1F, 0xCD, 0xF6, 0x05, 0xC2, 0xBB, 0x03, 0x11, 0x00, 0x1E, 0x7C, 0xFE, 0x1E, 0x38,
  0x07, 0xFE, 0x20, 0xDA, 0xBB, 0x03, 0x16, 0x28, 0xED, 0x53, 0xB1, 0x1F, 0x23, 0x22, 0xAF, 0x1F,
  0x18, 0xC5, 0x2A, 0xDC, 0x1F, 0x22, 0xDE, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0xCD, 0xDE, 0x03, 0x22,
  0xDE, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0xDD, 0x21, 0xCA, 0x07, 0xCD, 0xC4, 0x04, 0xC9, 0xCD, 0x02,
  0x04, 0xC9, 0x2A, 0xDE, 0x1F, 0x22, 0xAF, 0x1F, 0xCD, 0x3A, 0x04, 0xC9, 0xC3, 0xBB, 0x03, 0x2A,
  0xDE, 0x1F, 0xCD, 0xF6, 0x05, 0xC2, 0xBB, 0x03, 0xCD, 0xEE, 0x03, 0x79, 0xED, 0x6F, 0xCD, 0x0B,
  // Address 0x0200:
  0x04, 0xC9, 0x21, 0xDE, 0x1F, 0xCD, 0xFA, 0x03, 0x79, 0xED, 0x6F, 0x23, 0xED, 0x6F, 0xCD, 0x02,
  0x04, 0xC9, 0x79, 0xDD, 0x21, 0xB6, 0x1F, 0x21, 0xE3, 0x1F, 0x87, 0x77, 0xCD, 0x73, 0x04, 0xC9,
  0xCD, 0x55, 0x04, 0xCD, 0xFA, 0x03, 0x79, 0xED, 0x6F, 0x23, 0xED, 0x6F, 0xCD, 0x3A, 0x04, 0xC9,
  0xCD, 0xBB, 0x04, 0xCD, 0xEE, 0x03, 0x79, 0xED, 0x6F, 0xCD, 0x77, 0x04, 0xC9, 0xC3, 0xBB, 0x03,
  0x2A, 0xDE, 0x1F, 0x23, 0x22, 0xDE, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0x21, 0xE3, 0x1F, 0x34, 0xCD,
  0x5F, 0x04, 0x20, 0x04, 0x35, 0xC3, 0xBB, 0x03, 0xCD, 0x3A, 0x04, 0xC9, 0x21, 0xE3, 0x1F, 0x34,
  0x3E, 0x1F, 0xBE, 0x30, 0x02, 0x36, 0x00, 0xCD, 0x77, 0x04, 0xC9, 0xC3, 0xBB, 0x03, 0x2A, 0xDE,
  0x1F, 0x2B, 0x22, 0xDE, 0x1F, 0xCD, 0x0B, 0x04, 0xC9, 0x21, 0xE3, 0x1F, 0x35, 0xCD, 0x5F, 0x04,
  0x20, 0x04, 0x34, 0xC3, 0xBB, 0x03, 0xCD, 0x3A, 0x04, 0xC9, 0x21, 0xE3, 0x1F, 0x35, 0x3E, 0x1F,
  0xBE, 0x30, 0x02, 0x36, 0x1F, 0xCD, 0x77, 0x04, 0xC9, 0xC3, 0xBB, 0x03, 0x2A, 0xE0, 0x1F, 0x36,
  0xEF, 0x3E, 0xFF, 0x32, 0xEA, 0x1F, 0x3A, 0xD2, 0x1F, 0xCB, 0x47, 0x21, 0xFB, 0xC9, 0x20, 0x02,
  0x2E, 0xF3, 0x22, 0xEB, 0x1F, 0x31, 0xBC, 0x1F, 0xF1, 0xC1, 0xD1, 0xE1, 0x08, 0xF1, 0x08, 0xD9,
  0xC1, 0xD1, 0xE1, 0xD9, 0xDD, 0xE1, 0xFD, 0xE1, 0xED, 0x7B, 0xD0, 0x1F, 0x32, 0xBD, 0x1F, 0x3A,
  0xD3, 0x1F, 0xED, 0x47, 0xE5, 0x2A, 0xDE, 0x1F, 0xE3, 0x3A, 0xEA, 0x1F, 0xD3, 0x02, 0x3A, 0xBD,
  0x1F, 0xC3, 0xEB, 0x1F, 0x21, 0xAF, 0x1F, 0xCD, 0x3D, 0x05, 0x38, 0x67, 0xED, 0x5B, 0xB3, 0x1F,
  0xED, 0x52, 0x30, 0x0C, 0xEB, 0x09, 0x2B, 0xEB, 0x2A, 0xB1, 0x1F, 0xED, 0xB8, 0x13, 0x18, 0x1C,
  // Address 0x0300:
  0x19, 0xED, 0xB0, 0x1B, 0x18, 0x16, 0xED, 0x5B, 0xAF, 0x1F, 0x13, 0x13, 0x2A, 0xB1, 0x1F, 0xB7,
  0xED, 0x52, 0x7D, 0x17, 0x7C, 0xCE, 0x00, 0x20, 0x3A, 0x7D, 0x1B, 0x12, 0xED, 0x53, 0xDE, 0x1F,
  0xCD, 0x0B, 0x04, 0xC9, 0xCD, 0x2D, 0x05, 0x38, 0x2A, 0x32, 0xB5, 0x1F, 0x21, 0xA0, 0x0F, 0xCD,
  0xDE, 0x05, 0x21, 0xAF, 0x1F, 0x01, 0x07, 0x00, 0xCD, 0xA7, 0x05, 0x21, 0xA0, 0x0F, 0xCD, 0xE2,
  0x05, 0xCD, 0x3A, 0x05, 0xCD, 0xA7, 0x05, 0x21, 0xA0, 0x0F, 0xCD, 0xE2, 0x05, 0xED, 0x5B, 0xB3,
  0x1F, 0x18, 0xC9, 0xDD, 0x21, 0xA9, 0x07, 0xC3, 0xD0, 0x00, 0x2A, 0xAF, 0x1F, 0x22, 0xEA, 0x1F,
  0x3E, 0x40, 0xD3, 0x01, 0x21, 0xE8, 0x03, 0xCD, 0x8C, 0x05, 0x38, 0xF4, 0x2B, 0x7C, 0xB5, 0x20,
  0xF6, 0xCD, 0x8C, 0x05, 0x30, 0xFB, 0x21, 0xAF, 0x1F, 0x01, 0x07, 0x00, 0xCD, 0x4D, 0x05, 0x38,
  0xDF, 0xED, 0x5B, 0xAF, 0x1F, 0xCD, 0x65, 0x06, 0x06, 0x96, 0xCD, 0x24, 0x06, 0x10, 0xFB, 0x2A,
  0xEA, 0x1F, 0xB7, 0xED, 0x52, 0x20, 0xC9, 0x3E, 0x02, 0xD3, 0x01, 0xCD, 0x3A, 0x05, 0x38, 0xB3,
  0xCD, 0x4D, 0x05, 0x38, 0xAE, 0xCD, 0x2D, 0x05, 0x21, 0xB5, 0x1F, 0xBE, 0x20, 0xA5, 0x18, 0x9D,
  0x5E, 0x23, 0x56, 0x23, 0x85, 0x6F, 0x6E, 0x26, 0x00, 0x19, 0xE9, 0x21, 0xE6, 0x1F, 0xCB, 0xFE,
  0xC9, 0xDD, 0x21, 0x08, 0x07, 0x0E, 0x28, 0x06, 0x10, 0xCD, 0x24, 0x06, 0x10, 0xFB, 0xDD, 0x2B,
  0x0D, 0x20, 0xF4, 0x3E, 0xA5, 0xC3, 0xB3, 0x06, 0x21, 0x66, 0x00, 0x22, 0xEE, 0x1F, 0x21, 0xFF,
  0xFF, 0x22, 0xE0, 0x1F, 0xC9, 0x3A, 0xE4, 0x1F, 0xFE, 0x01, 0xC8, 0xFE, 0x02, 0xC9, 0x3A, 0xE6,
  0x1F, 0xB7, 0xC8, 0x3E, 0x00, 0x77, 0x32, 0xE6, 0x1F, 0xC9, 0xCD, 0xEE, 0x03, 0xC8, 0x23, 0x77,
  // Address 0x0400:
  0x2B, 0xC9, 0x3E, 0x01, 0x06, 0x04, 0x21, 0xB8, 0x1F, 0x18, 0x07, 0x3E, 0x02, 0x06, 0x02, 0x21,
  0xB6, 0x1F, 0x32, 0xE4, 0x1F, 0xD9, 0xED, 0x5B, 0xDE, 0x1F, 0xCD, 0x65, 0x06, 0x1A, 0xCD, 0x71,
  0x06, 0x2A, 0xE0, 0x1F, 0x7E, 0x32, 0xE2, 0x1F, 0xB7, 0xED, 0x52, 0x20, 0x06, 0x06, 0x06, 0x21,
  0xB6, 0x1F, 0xD9, 0xD9, 0xCB, 0xF6, 0x23, 0x10, 0xFB, 0xC9, 0xCD, 0x55, 0x04, 0x5E, 0x23, 0x56,
  0xCD, 0x65, 0x06, 0x21, 0xB8, 0x1F, 0x06, 0x04, 0xCD, 0x34, 0x04, 0xCD, 0x5F, 0x04, 0x6F, 0x26,
  0x02, 0x22, 0xB6, 0x1F, 0xC9, 0x3A, 0xE3, 0x1F, 0x87, 0x21, 0xAF, 0x1F, 0x85, 0x6F, 0xC9, 0x3A,
  0xE4, 0x1F, 0xD6, 0x04, 0x87, 0x87, 0x11, 0xBC, 0x07, 0x83, 0x5F, 0x3A, 0xE3, 0x1F, 0x83, 0x5F,
  0x1A, 0xB7, 0xC9, 0x3E, 0x08, 0x18, 0x02, 0x3E, 0x09, 0x32, 0xE4, 0x1F, 0x3A, 0xE3, 0x1F, 0xCB,
  0x87, 0x47, 0xCD, 0xAE, 0x04, 0x78, 0xCD, 0xBE, 0x04, 0x5E, 0x23, 0x56, 0xED, 0x53, 0xDE, 0x1F,
  0xCD, 0x65, 0x06, 0x3A, 0xE4, 0x1F, 0xFE, 0x09, 0xC0, 0x21, 0xB8, 0x1F, 0x3A, 0xE3, 0x1F, 0xCB,
  0x47, 0x28, 0x02, 0x23, 0x23, 0xCB, 0xF6, 0x23, 0xCB, 0xF6, 0xCD, 0xC4, 0x04, 0xC9, 0x21, 0xD0,
  0x07, 0x85, 0x6F, 0x5E, 0x23, 0x56, 0xED, 0x53, 0xB6, 0x1F, 0xC9, 0x3A, 0xE3, 0x1F, 0x21, 0xBC,
  0x1F, 0x85, 0x6F, 0xC9, 0x3A, 0xE3, 0x1F, 0xB7, 0x1F, 0xFE, 0x0B, 0x28, 0x09, 0x4F, 0x21, 0xD2,
  0x1F, 0x7E, 0xE6, 0x01, 0x77, 0x79, 0xFE, 0x0C, 0x30, 0x1F, 0x3A, 0xBC, 0x1F, 0xCD, 0x18, 0x05,
  0x22, 0xD4, 0x1F, 0xCD, 0x18, 0x05, 0x22, 0xD6, 0x1F, 0x3A, 0xC4, 0x1F, 0xCD, 0x18, 0x05, 0x22,
  0xD8, 0x1F, 0xCD, 0x18, 0x05, 0x22, 0xDA, 0x1F, 0xC9, 0x2A, 0xD4, 0x1F, 0xCD, 0x23, 0x05, 0x2A,
  // Address 0x0500:
  0xD6, 0x1F, 0xCD, 0x23, 0x05, 0x32, 0xBC, 0x1F, 0x2A, 0xD8, 0x1F, 0xCD, 0x23, 0x05, 0x2A, 0xDA,
  0x1F, 0xCD, 0x23, 0x05, 0x32, 0xC4, 0x1F, 0xC9, 0x06, 0x04, 0x29, 0x29, 0x29, 0x07, 0xED, 0x6A,
  0x10, 0xF8, 0xC9, 0x06, 0x04, 0x29, 0x29, 0x29, 0x29, 0x17, 0x10, 0xF9, 0xC9, 0xCD, 0x3A, 0x05,
  0xD8, 0xAF, 0x86, 0xED, 0xA1, 0xEA, 0x32, 0x05, 0xB7, 0xC9, 0x21, 0xB1, 0x1F, 0x5E, 0x23, 0x56,
  0x23, 0x4E, 0x23, 0x66, 0x69, 0xB7, 0xED, 0x52, 0x4D, 0x44, 0x03, 0xEB, 0xC9, 0xAF, 0x08, 0xCD,
  0x5A, 0x05, 0x73, 0xED, 0xA1, 0xEA, 0x4F, 0x05, 0x08, 0xC9, 0xCD, 0x6B, 0x05, 0x16, 0x08, 0xCD,
  0x6B, 0x05, 0xCB, 0x1B, 0x15, 0x20, 0xF8, 0xCD, 0x6B, 0x05, 0xC9, 0xD9, 0x21, 0x00, 0x00, 0xCD,
  0x8C, 0x05, 0x14, 0x15, 0x20, 0x11, 0x38, 0x06, 0x2D, 0x2D, 0xCB, 0xC4, 0x18, 0xF1, 0x2C, 0xCB,
  0x44, 0x28, 0xEC, 0xCB, 0x15, 0xD9, 0xC9, 0x08, 0x37, 0x08, 0xD9, 0xC9, 0x11, 0x00, 0x00, 0xDB,
  0x00, 0x13, 0x17, 0x38, 0xFA, 0x3E, 0xFF, 0xD3, 0x02, 0xDB, 0x00, 0x13, 0x17, 0x30, 0xFA, 0x3E,
  0x7F, 0xD3, 0x02, 0x7B, 0xFE, 0x2A, 0xC9, 0x5E, 0xCD, 0xB1, 0x05, 0xED, 0xA1, 0xEA, 0xA7, 0x05,
  0xC9, 0x16, 0x08, 0xB7, 0xCD, 0xC4, 0x05, 0xCB, 0x1B, 0xCD, 0xC4, 0x05, 0x15, 0x20, 0xF8, 0x37,
  0xCD, 0xC4, 0x05, 0xC9, 0xD9, 0x26, 0x00, 0x38, 0x09, 0x2E, 0x08, 0xCD, 0xE2, 0x05, 0x2E, 0x02,
  0x18, 0x07, 0x2E, 0x04, 0xCD, 0xE2, 0x05, 0x2E, 0x04, 0xCD, 0xDE, 0x05, 0xD9, 0xC9, 0x0E, 0x41,
  0x18, 0x02, 0x0E, 0x1F, 0x29, 0x11, 0x01, 0x00, 0x3E, 0xFF, 0xD3, 0x02, 0x41, 0x10, 0xFE, 0xEE,
  0x80, 0xED, 0x52, 0x20, 0xF5, 0xC9, 0x7E, 0x2F, 0x77, 0x7E, 0x2F, 0x77, 0xBE, 0xC9, 0xDD, 0xE5,
  // Address 0x0600:
  0x21, 0xE6, 0x1F, 0xCB, 0x7E, 0x28, 0x04, 0xDD, 0x21, 0xA5, 0x07, 0x06, 0x04, 0xCD, 0x24, 0x06,
  0x30, 0xF9, 0x10, 0xF9, 0xCB, 0xBE, 0xDD, 0xE1, 0xCD, 0x24, 0x06, 0x38, 0xFB, 0x21, 0x7B, 0x07,
  0x85, 0x6F, 0x7E, 0xC9, 0x37, 0x08, 0xD9, 0x0E, 0x00, 0x1E, 0xC1, 0x26, 0x06, 0x7B, 0xD3, 0x02,
  0xDD, 0x7E, 0x00, 0xD3, 0x01, 0x06, 0xC9, 0x10, 0xFE, 0xAF, 0xD3, 0x01, 0x7B, 0x2F, 0xF6, 0xC0,
  0xD3, 0x02, 0x06, 0x06, 0xDB, 0x00, 0x57, 0xCB, 0x1A, 0x38, 0x02, 0x79, 0x08, 0x0C, 0x10, 0xF7,
  0xDD, 0x23, 0x7B, 0xE6, 0x3F, 0xCB, 0x07, 0xF6, 0xC0, 0x5F, 0x25, 0x20, 0xD0, 0x11, 0xFA, 0xFF,
  0xDD, 0x19, 0xD9, 0x08, 0xC9, 0x21, 0xB8, 0x1F, 0x7B, 0xCD, 0x78, 0x06, 0x7A, 0xCD, 0x78, 0x06,
  0xC9, 0x21, 0xB6, 0x1F, 0xCD, 0x78, 0x06, 0xC9, 0xF5, 0xCD, 0x89, 0x06, 0x77, 0x23, 0xF1, 0x0F,
  0x0F, 0x0F, 0x0F, 0xCD, 0x89, 0x06, 0x77, 0x23, 0xC9, 0xE5, 0x21, 0xF0, 0x07, 0xE6, 0x0F, 0x85,
  0x6F, 0x7E, 0xE1, 0xC9, 0x21, 0x00, 0x18, 0x01, 0x00, 0x08, 0xCD, 0xF6, 0x05, 0x28, 0x01, 0x76,
  0xED, 0xA1, 0xEA, 0x9A, 0x06, 0xC7, 0x21, 0x00, 0x00, 0x01, 0x00, 0x08, 0xCD, 0x31, 0x05, 0x28,
  0x01, 0x76, 0xC7, 0x32, 0xE5, 0x1F, 0x3E, 0x55, 0x32, 0xF0, 0x1F, 0x3E, 0x44, 0x32, 0xF1, 0x1F,
  0x21, 0xF2, 0x1F, 0x36, 0x2F, 0x23, 0x36, 0x00, 0xC3, 0xD8, 0x03, 0xF5, 0x21, 0xF1, 0x1F, 0x4E,
  0x2A, 0xF2, 0x1F, 0x3A, 0xF0, 0x1F, 0xFE, 0x55, 0x20, 0x03, 0xCD, 0xE4, 0x05, 0xF1, 0xC3, 0xE9,
  0x00, 0xB5, 0x1F, 0x8D, 0xFD, 0xBF, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x3D, 0xB5,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x0D, 0x87, 0x8D, 0x8F, 0x85, 0x8F, 0x00, 0x00, 0x00,
  // Address 0x0700:
  0x00, 0x00, 0x00, 0xAE, 0x3D, 0x85, 0xB5, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x01, 0x00, 0x05, 0x0A, 0x0F, 0x1A, 0x2C, 0x42,
  0x7B, 0xC2, 0x01, 0x00, 0x1C, 0x0A, 0x14, 0x20, 0x20, 0x26, 0x26, 0xEC, 0x01, 0x00, 0x16, 0x03,
  0x26, 0x34, 0x34, 0x34, 0x34, 0x26, 0x44, 0x3D, 0x02, 0x00, 0x03, 0x03, 0x00, 0x0E, 0x0E, 0x0E,
  0x0E, 0x1F, 0x1F, 0x6B, 0x02, 0x00, 0x03, 0x03, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x1F, 0x1F, 0x99,
  0x02, 0x00, 0x03, 0x03, 0x00, 0x4B, 0x6D, 0x8B, 0xC1, 0x00, 0x00, 0x03, 0x07, 0x0B, 0x0F, 0x20,
  0x21, 0x02, 0x06, 0x0A, 0x0E, 0x22, 0x23, 0x01, 0x05, 0x09, 0x0D, 0x13, 0x1F, 0x00, 0x04, 0x08,
  0x0C, 0x12, 0x1E, 0x1A, 0x18, 0x1B, 0x19, 0x17, 0x1D, 0x15, 0x11, 0x14, 0x10, 0x16, 0x1C, 0xB5,
  0x1F, 0x8D, 0xFD, 0xBF, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x8F, 0x02, 0x1F,
  0xAE, 0x02, 0xAE, 0xB6, 0xAE, 0x1F, 0xAE, 0x02, 0x03, 0x03, 0x8F, 0x00, 0xAE, 0x8F, 0xB3, 0x00,
  0xAE, 0xB3, 0x00, 0x00, 0x0F, 0xAE, 0x8F, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x02, 0xBE, 0x8F, 0x03,
  0x0F, 0x3F, 0x8D, 0xA7, 0x8F, 0xB3, 0x85, 0x37, 0x4F, 0x3F, 0xCD, 0xA7, 0xCF, 0xB3, 0xC5, 0x37,
  0x07, 0x30, 0xB6, 0x30, 0x1F, 0xAE, 0x0F, 0x30, 0x37, 0x0F, 0x85, 0x0F, 0x77, 0x0F, 0xC5, 0x0F,
  0xBD, 0x30, 0x9B, 0xBA, 0x36, 0xAE, 0xAF, 0x38, 0xBF, 0xBE, 0x3F, 0xA7, 0x8D, 0xB3, 0x8F, 0x0F
};

String activePath;
String chkFile = "";
bool isReadySD = false;

void setup() {
  Serial.begin(57600);
  while (!Serial); // wait for serial port to connect. Needed for native USB port only
  
  Serial.println(F("*** Arduino Mega 2560 ROM/RAM Writer for MPF-1 ***"));
  
  Serial.print(F("\nLoading ROM..."));
  writeROM();
  Serial.println(F("done"));
  
  Serial.println(F("\nTo begin, please send any word via Serial Monitor..."));
}

void loop() {
  static String command = "";
  static String param = "";
  static SERIAL_STATE serialStat = BEGIN;
  char inChar;
  File file;
  
  while (Serial.available()) {
    inChar = Serial.read();
    if (inChar == '\n') {
      command.toUpperCase();
      param.toUpperCase();
      
      if (command == "ATTACH") {
        if (isReadySD && chkFileExistence())
            Serial.println(F("\nSD card already been attached"));
        else {
          if (isReadySD) {
            SD.end();
            isReadySD = false;
          }
          Serial.print(F("\nIntializing SD card..."));
          if (SD.begin(SDCARD_CS_PIN)) {
            Serial.println(F("done"));
            file = SD.open("").openNextFile();
            if (file) {
              chkFile = String(file.name());
              file.close();
            }
            else {
              chkFile = "";
              Serial.println(F("Warning: SD card is empty"));
            }
            isReadySD = true;
            activePath = "";
          }
          else
            Serial.println(F("failed"));
        }
      }
      
      else if (command == "EJECT") {
        if (isReadySD) {
          SD.end();
          isReadySD = false;
          Serial.println(F("\nSD card ejected"));
        }
        else
          Serial.println(F("\nSD card already been ejected"));
      }
      
      else if (command == "DIR")
        printDir(param);
      
      else if (command == "CD")
        chgDir(param);
      
      else if (command == "DUMP")
        dumpFile(param);
      
      else if (command == "LOAD")
        loadFile(param);
      
      else if (command == "HELP") {
        Serial.println(F("\nAll available commands:"));
        Serial.println(F("\"ATTACH\""));
        Serial.println(F("   Must be called first before all other commands or after inserting a new SD card."));
        Serial.println(F("\"EJECT\""));
        Serial.println(F("   Must be called before ejecting current SD card."));
        Serial.println(F("\"DIR [directory_path]\""));
        Serial.println(F("   List all available folder or file in the specified directory_path."));
        Serial.println(F("\"CD [directory_path]\""));
        Serial.println(F("   Change current active directory to the specified directory_path."));
        Serial.println(F("\"DUMP file_path\""));
        Serial.println(F("   Printout all the content of the specified file_path."));
        Serial.println(F("\"LOAD file_path\""));
        Serial.println(F("   Load the specified file_path to the MPF-1."));
      }

      else if (command == "TEST") {
        Serial.println("Exists: \"" + String(SD.exists(param)) + "\"");
      }

      else {
        Serial.println("\nUnknown \"" + command + "\" command");
        Serial.println(F("Please try \"HELP\" command"));
      }
      
      command = "";
      param = "";
      serialStat = BEGIN;
    }
    
    else if (inChar == ' ') {
      if (serialStat == COMMAND)
        serialStat = SPACE;
      else if (serialStat == PARAM)
        serialStat = AVOID;
    }
    
    else {
      switch (serialStat) {
        case BEGIN:
          command += inChar;
          serialStat = COMMAND;
          break;
        case COMMAND:
          command += inChar;
          break;
        case SPACE:
          param += inChar;
          serialStat = PARAM;
          break;
        case PARAM:
          param += inChar;
      }
    }
  }
}

void printDir(String &path) {
  String actualPath;
  if (!chkPath(actualPath, path))
    return;
  File dir = SD.open(actualPath);
  if (!dir.isDirectory()) {
    getParentPath(actualPath);
    Serial.println("\nDirectory of \"/" + actualPath + "\":");
    Serial.print(String(dir.name()) + '\t');
    if (String(dir.name()).length() < 8)
      Serial.print('\t');
    Serial.println(String(dir.size(), DEC));
  }
  else {
    File entry;
    Serial.println("\nDirectory of \"/" + actualPath + "\":");
    while (true) {
      entry = dir.openNextFile();
      if (!entry)
        break;
      Serial.print(String(entry.name()) + '\t');
      if (String(entry.name()).length() < 8)
        Serial.print('\t');
      Serial.println((entry.isDirectory()) ? "<DIR>" : String(entry.size(), DEC));
      entry.close();
    }
  }
  dir.close();
}

void chgDir(String &path) {
  String actualPath;
  if (!chkPath(actualPath, path))
    return;
  File dir = SD.open(actualPath);
  if (!dir.isDirectory())
    Serial.print("\n\"/" + actualPath + "\" isn't a directory");
  else
    activePath = actualPath;
  dir.close();
  Serial.println("\nActive directory: \"/" + activePath + '\"');
}

void dumpFile(String &path) {
  if (path == "") {
    Serial.println(F("\nNo file to dump"));
    return;
  }
  String actualPath;
  if (!chkPath(actualPath, path))
    return;
  File file = SD.open(actualPath);
  if (file.isDirectory())
    Serial.println("\n\"/" + actualPath + "\" isn't a file");
  else {
    Serial.println("\nContent of \"/" + actualPath + "\":");
    while (file.available())
      Serial.write(file.read());
    Serial.println();
  }
  file.close();
}

void loadFile(String &path) {
  if (path == "") {
    Serial.println(F("\nNo file to load"));
    return;
  }
  String actualPath;
  if (!chkPath(actualPath, path))
    return;
  File file = SD.open(actualPath);
  if (file.isDirectory())
    Serial.println("\n\"/" + actualPath + "\" isn't a file");
  else {
    Serial.print("\nLoading \"" + actualPath + "\"...");
    uint16_t line;
    HEX_FILE_STATUS stat = hexFileToMem(file, line);
    if (stat == END_OF_FILE)
      Serial.println(F("done"));
    else {
      Serial.println("failed on line " + String(line));
      switch (stat) {
        case INVALID_START_CODE:
          Serial.println(F("Error: Invalid start code"));
          break;
        case INVALID_DATA_COUNT:
          Serial.println(F("Error: Invalid data count"));
          break;
        case EXCEED_16_BYTES_DATA:
          Serial.println(F("Error: Exceed 16-bytes data per line"));
          break;
        case INVALID_ADDRESS:
          Serial.println(F("Error: Invalid address value"));
          break;
        case INVALID_RECORD_TYPE:
          Serial.println(F("Error: Invalid record type"));
          break;
        case UNSUPPORTED_RECORD_TYPE:
          Serial.println(F("Error: Unsupported record type"));
          break;
        case INVALID_DATA:
          Serial.println(F("Error: Invalid data"));
          break;
        case INVALID_CHECKSUM:
          Serial.println(F("Error: Invalid checksum"));
          break;
        case INVALID_END_OF_FILE:
          Serial.println(F("Error: Invalid End Of File"));
      }
    }
  }
  file.close();
}

bool chkPath(String &actualPath, String &path) {
  if (!chkSDC())
    return false;
  actualPath = getActualPath(path);
  if (actualPath != "" && !SD.exists(actualPath)) {
    Serial.println("\nCan't find \"/" + actualPath + '\"');
    return false;
  }
  return true;
}

bool chkSDC() {
  if (isReadySD) {
    if (chkFileExistence())
      return true;
    else {
      SD.end();
      isReadySD = false;
      Serial.println(F("\nCan't access SD card"));
      Serial.println(F("SD card ejected"));
    }
  }
  else
    Serial.println(F("\nSD card wasn't ready"));
  return false;
}

bool chkFileExistence() {
  if (chkFile == "")
    return true;
  return SD.exists(chkFile);  
}

String getActualPath(String &path) {
  String actualPath = (path.startsWith("/")) ? "" : activePath;
  String dir;
  while (true) {
    dir = getFirstDir(path);
    if (dir == "" && path == "")
      break;
    else if (dir == "..")
      getParentPath(actualPath);
    else if (dir != "" && dir != ".") {
      if (actualPath == "")
        actualPath = dir;
      else
        actualPath += '/' + dir;
    }
  }
  return actualPath;
}

String getFirstDir(String &path) {
  String dir;
  int idx = path.indexOf('/');
  if (idx >= 0) {
    dir = path.substring(0, idx);
    path.remove(0, idx + 1);
  }
  else {
    dir = path;
    path = "";
  }
  return dir;
}

void getParentPath(String &path) {
  int idx = path.lastIndexOf('/');
  if (idx >= 0)
    path.remove(idx);
  else
    path = "";
}

HEX_FILE_STATUS hexFileToMem(File hexFile, uint16_t &lineCount) {
  uint8_t dataLen, i;
  uint16_t addr;
  uint8_t dataBuf[16];
  HEX_FILE_STATUS stat;
  
  lineCount = 1;
  driveBusControl();
  while (true) {
    stat = getLine(hexFile, dataLen, addr, dataBuf);
    if (stat != OK)
      break;
    for (i = 0; i < dataLen; ++i)
      writeMem(addr++, dataBuf[i]);
    ++lineCount;
  }
  releaseBusControl();
  return stat;
}

HEX_FILE_STATUS getLine(File hexFile, uint8_t &dataLen, uint16_t &addr, uint8_t *dataBuf) {
  uint8_t recType, chksum, chr;
  
  while (true) {
    if (!getChar(hexFile, chr))
      return INVALID_START_CODE;
    if (chr == ':')
      break;
    if (chr != '\r' && chr != '\n')
      return INVALID_START_CODE;
  }
  
  if (!getByte(hexFile, dataLen))
    return INVALID_DATA_COUNT;
  if (dataLen > 16)
    return EXCEED_16_BYTES_DATA;
  chksum = dataLen;
  
  if (!getByte(hexFile, chr))
    return INVALID_ADDRESS;
  addr = chr << 8;
  chksum += chr;
  if (!getByte(hexFile, chr))
    return INVALID_ADDRESS;
  addr |= chr;
  chksum += chr;
  
  if (!getByte(hexFile, recType))
    return INVALID_RECORD_TYPE;
  if (recType > 5)
    return INVALID_RECORD_TYPE;
  if (recType > 1)
    return UNSUPPORTED_RECORD_TYPE;
  chksum += recType;
  
  if (recType == 0) {
    for (uint8_t i = 0; i < dataLen; ++i) {
      if (!getByte(hexFile, chr))
        return INVALID_DATA;
      dataBuf[i] = chr;
      chksum += chr;
    }
  }
  
  if (!getByte(hexFile, chr))
    return INVALID_CHECKSUM;
  chksum = ~chksum;
  chksum += 1;
  if (chksum != chr)
    return INVALID_CHECKSUM;
  
  if (recType == 0)
    return OK;
  return (dataLen == 0) ? END_OF_FILE : INVALID_END_OF_FILE;
}

bool getByte(File hexFile, uint8_t &chr) {
  uint8_t by, nibble;
  if (!getHexCodedNibble(hexFile, nibble))
    return false;
  by = nibble << 4;
  if (!getHexCodedNibble(hexFile, nibble))
    return false;
  chr = by | nibble;
  return true;
}

bool getHexCodedNibble(File hexFile, uint8_t &nibble) {
  uint8_t chr;
  if (!getChar(hexFile, chr))
    return false;
  if (isDigit(chr))
    chr &= 15;
  else {
    chr &= 0xDF;
    chr -= 55;
  }
  if (chr > 15)
    return false;
  nibble = chr;
  return true;
}

bool getChar(File hexFile, uint8_t &chr) {
  if (!hexFile.available())
    return false;
  chr = hexFile.read();
  return true;
}

void writeROM() {
  driveBusControl();
  for(uint16_t i = 0; i < ROM_SIZE; ++i)
    writeMem(ROM_ADDRESS + i, pgm_read_byte(ROM_DATA + i));
  releaseBusControl();
}

void driveBusControl() {
  drive_RST();
  delay(10);
  release_RST();
  drive_BUSREQ();
  while (!is_BUSACK());
  drive_MREQ();
  drive_IORQ();
  drive_WR();
  drive_RD();
  drive_ROM_WR();
}

void releaseBusControl() {
  drive_RST();
  release_WR();
  release_RD();
  release_MREQ();
  release_IORQ();
  release_BUSREQ();
  release_ROM_WR();
  delay(10);
  release_RST();
}

void writeMem(uint16_t addr, uint8_t dt) {
  drive_ADDR_BUS();
  put_ADDR_BUS(addr);
  drive_DATA_BUS();
  put_DATA_BUS(dt);
  set_MREQ(0);
#if USE_ROM_WR
  set_ROM_WR(0);
#else
  set_WR(0);
#endif
  NOP;
  NOP;
#if USE_ROM_WR
  set_ROM_WR(1);
#else
  set_WR(1);
#endif
  set_MREQ(1);
  NOP;
  release_DATA_BUS();
  release_ADDR_BUS();
}

uint8_t readMem(uint16_t addr) {
  uint8_t dt;
  drive_ADDR_BUS();
  put_ADDR_BUS(addr);
  set_MREQ(0);
  set_RD(0);
  NOP;
  NOP;    // until 120ns required
  dt = get_DATA_BUS();
  set_RD(1);
  set_MREQ(1);
  NOP;
  release_ADDR_BUS();
  return dt;
}

void writeIO(uint16_t addr, uint8_t dt) {
  drive_ADDR_BUS();
  put_ADDR_BUS(addr);
  drive_DATA_BUS();
  put_DATA_BUS(dt);
  set_IORQ(0);
  set_WR(0);
  NOP;
  NOP;
  set_WR(1);
  set_IORQ(1);
  NOP;
  release_DATA_BUS();
  release_ADDR_BUS();
}

uint8_t readIO(uint16_t addr) {
  uint8_t dt;
  drive_ADDR_BUS();
  put_ADDR_BUS(addr);
  set_IORQ(0);
  set_RD(0);
  NOP;
  NOP;    // until 120ns required
  dt = get_DATA_BUS();
  set_RD(1);
  set_IORQ(1);
  NOP;
  release_ADDR_BUS();
  return dt;
}
